@namespace ChessBlazor.Components.Chess

@using global::Chess.Programming.Ago.ChessEngines
@using global::Chess.Programming.Ago.Pieces
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using System.Globalization

<div class="minimax-fullscreen">
    <div class="header">
        <div class="header-left">
            <h1>Minimax Algorithm</h1>
            @if (SearchResult != null) {
                <div class="stats-row">
                    <div class="stat-chip">
                        <span class="stat-label">Depth</span>
                        <span class="stat-value">@SearchResult.SearchDepth</span>
                    </div>
                    <div class="stat-chip">
                        <span class="stat-label">Total Nodes</span>
                        <span class="stat-value">@SearchResult.TotalNodesEvaluated.ToString("N0")</span>
                    </div>
                    <div class="stat-chip">
                        <span class="stat-label">Visible</span>
                        <span class="stat-value">@visibleNodesCount.ToString("N0")</span>
                    </div>
                    <div class="stat-chip">
                        <span class="stat-label">Pruned</span>
                        <span class="stat-value">@SearchResult.NodesPruned.ToString("N0")</span>
                    </div>
                    <div class="stat-chip @(SearchResult.AlphaBetaEnabled ? "stat-active" : "")">
                        <span class="stat-label">Alpha-Beta</span>
                        <span class="stat-value">@(SearchResult.AlphaBetaEnabled ? "ON" : "OFF")</span>
                    </div>
                </div>
            }
        </div>
        <button class="close-btn" @onclick="OnClose">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
        </button>
    </div>

    @if (SearchResult == null) {
        <div class="empty-state">
            <h2>No Search Data</h2>
            <p>Make a move with the AI player to visualize the algorithm</p>
        </div>
    } else {
        <div class="controls-bar">
            <div class="playback-controls">
                <button class="control-btn" @onclick="Reset" disabled="@(currentStep == 0)" title="Reset">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                    </svg>
                </button>
                <button class="control-btn" @onclick="StepBack" disabled="@(currentStep == 0)" title="Back">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>
                    </svg>
                </button>
                @if (isPlaying) {
                    <button class="control-btn control-btn-primary" @onclick="Pause" title="Pause">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                } else {
                    <button class="control-btn control-btn-primary" @onclick="Play" disabled="@(currentStep >= maxSteps)" title="Play">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </button>
                }
                <button class="control-btn" @onclick="StepForward" disabled="@(currentStep >= maxSteps)" title="Forward">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M13 6v12l8.5-6L13 6zM4 18l8.5-6L4 6v12z"/>
                    </svg>
                </button>
                <button class="control-btn" @onclick="SkipToEnd" disabled="@(currentStep >= maxSteps)" title="End">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                    </svg>
                </button>
            </div>

            <div class="view-modes">
                <button class="mode-btn @(viewMode == ViewMode.BestPath ? "active" : "")" @onclick="() => SetViewMode(ViewMode.BestPath)">
                    Best Path
                </button>
                <button class="mode-btn @(viewMode == ViewMode.CurrentBranch ? "active" : "")" @onclick="() => SetViewMode(ViewMode.CurrentBranch)">
                    Current Branch
                </button>
                <button class="mode-btn @(viewMode == ViewMode.Evaluated ? "active" : "")" @onclick="() => SetViewMode(ViewMode.Evaluated)">
                    Evaluated (@visitedNodeIds.Count)
                </button>
                <button class="mode-btn @(viewMode == ViewMode.TreeDiagram ? "active" : "")" @onclick="() => SetViewMode(ViewMode.TreeDiagram)">
                    Tree Diagram
                </button>
            </div>

            <div class="depth-control">
                <span class="depth-label">Depth:</span>
                <select @bind="maxVisibleDepth" class="depth-select">
                    @for (int d = 1; d <= Math.Min(SearchResult.SearchDepth, 5); d++) {
                        <option value="@d">@d</option>
                    }
                </select>
            </div>

            <div class="limit-control">
                <span class="depth-label">Max nodes:</span>
                <select @bind="maxRenderedNodes" class="depth-select">
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="200">200</option>
                    <option value="500">500</option>
                </select>
            </div>

            <div class="speed-slider">
                <span class="speed-label">Speed</span>
                <input type="range" min="20" max="500" step="20" @bind="speedMs" @bind:event="oninput" />
                <span class="speed-value">@speedMs ms</span>
            </div>

            <div class="progress-display">
                <span class="progress-text">Step @currentStep / @maxSteps</span>
            </div>
        </div>

        <div class="legend-bar">
            <div class="legend-item"><div class="legend-dot legend-max"></div><span>MAX</span></div>
            <div class="legend-item"><div class="legend-dot legend-min"></div><span>MIN</span></div>
            <div class="legend-item"><div class="legend-dot legend-pruned"></div><span>Pruned</span></div>
            <div class="legend-item"><div class="legend-dot legend-best"></div><span>Best</span></div>
            <div class="legend-item"><div class="legend-dot legend-current"></div><span>Current</span></div>
        </div>

        @* Current node detail panel *@
        @if (currentNode != null) {
            <div class="detail-panel">
                <div class="detail-board">
                    @if (currentNode.BoardState != null) {
                        @for (int row = 0; row < 8; row++) {
                            <div class="detail-row">
                                @for (int col = 0; col < 8; col++) {
                                    var isLight = (row + col) % 2 == 0;
                                    var piece = currentNode.BoardState[row, col];
                                    var isFrom = currentNode.Move?.From.Row == row && currentNode.Move?.From.Column == col;
                                    var isTo = currentNode.Move?.To.Row == row && currentNode.Move?.To.Column == col;
                                    <div class="detail-cell @(isLight ? "light" : "dark") @(isFrom ? "from" : "") @(isTo ? "to" : "")">
                                        @if (piece != null) {
                                            <span class="@(piece.Color == PieceColor.White ? "white-piece" : "black-piece")">
                                                @GetPieceSymbol(piece.Type, piece.Color)
                                            </span>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                </div>
                <div class="detail-info">
                    <div class="detail-move">@currentNode.MoveNotation</div>
                    <div class="detail-type @(currentNode.IsMaximizing ? "type-max" : "type-min")">
                        @(currentNode.IsMaximizing ? "MAXIMIZING" : "MINIMIZING")
                    </div>
                    @if (currentNode.Score.HasValue) {
                        <div class="detail-score">Score: @FormatScore(currentNode.Score.Value)</div>
                    }
                    <div class="detail-ab">α: @FormatScore(currentNode.Alpha) | β: @FormatScore(currentNode.Beta)</div>
                    @if (currentNode.IsPruned) {
                        <div class="detail-pruned">PRUNED</div>
                    }
                </div>
            </div>
        }

        @if (viewMode == ViewMode.TreeDiagram) {
            @* Visual Tree Diagram *@
            <div class="tree-diagram-container">
                @{
                    var (diagramNodes, diagramEdges, svgWidth, svgHeight) = CalculateTreeLayout();
                    visibleNodesCount = diagramNodes.Count;
                }
                
                <div class="tree-diagram-info">
                    <p>This diagram shows the <strong>best path</strong> (highlighted in blue) along with <strong>example branches</strong> to demonstrate alpha-beta pruning. 
                    Pruned branches are shown with dashed lines and striped nodes.</p>
                </div>
                
                <div class="tree-diagram-scroll">
                    <svg class="tree-svg" 
                         width="@(Math.Max(svgWidth + 100, 800))" 
                         height="@(Math.Max(svgHeight + 50, 400))"
                         viewBox="0 0 @(Math.Max(svgWidth + 100, 800)) @(Math.Max(svgHeight + 50, 400))">
                        
                        <defs>
                            @* Pattern for pruned nodes *@
                            <pattern id="prunedPattern" patternUnits="userSpaceOnUse" width="8" height="8">
                                <path d="M-2,2 l4,-4 M0,8 l8,-8 M6,10 l4,-4" stroke="#8e8e93" stroke-width="1.5" opacity="0.4"/>
                            </pattern>
                            @* Arrow marker for edges *@
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#86868b"/>
                            </marker>
                            <marker id="arrowhead-best" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#007aff"/>
                            </marker>
                            <marker id="arrowhead-pruned" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#ff3b30"/>
                            </marker>
                        </defs>
                        
                        @* Draw edges first (behind nodes) *@
                        @foreach (var edge in diagramEdges) {
                            var edgeClass = GetTreeEdgeClass(edge);
                            var markerId = edge.IsPruned ? "arrowhead-pruned" : (edge.IsOnBestPath ? "arrowhead-best" : "arrowhead");
                            
                            @* Curved path for edge *@
                            <path class="@edgeClass"
                                  d="M @edge.X1.ToString(CultureInfo.InvariantCulture) @edge.Y1.ToString(CultureInfo.InvariantCulture) C @edge.X1.ToString(CultureInfo.InvariantCulture) @((edge.Y1 + 40).ToString(CultureInfo.InvariantCulture)), @edge.X2.ToString(CultureInfo.InvariantCulture) @((edge.Y2 - 40).ToString(CultureInfo.InvariantCulture)), @edge.X2.ToString(CultureInfo.InvariantCulture) @edge.Y2.ToString(CultureInfo.InvariantCulture)"
                                  marker-end="url(#@markerId)" />
                            
                            @* Pruning indicator on pruned edges *@
                            @if (edge.IsPruned) {
                                var midX = (edge.X1 + edge.X2) / 2;
                                var midY = (edge.Y1 + edge.Y2) / 2;
                                <g class="prune-indicator" transform="translate(@midX.ToString(CultureInfo.InvariantCulture), @midY.ToString(CultureInfo.InvariantCulture))">
                                    <circle r="12" fill="#ff3b30" />
                                    <foreignObject x="-12" y="-12" width="24" height="24">
                                        <div xmlns="http://www.w3.org/1999/xhtml" class="svg-prune-icon">✂</div>
                                    </foreignObject>
                                </g>
                            }
                        }
                        
                        @* Draw nodes *@
                        @foreach (var diagNode in diagramNodes) {
                            var node = diagNode.Node;
                            var nodeClass = GetTreeNodeClass(node, diagNode.IsOnBestPath);
                            var fillColor = node.IsPruned 
                                ? "url(#prunedPattern)" 
                                : (node.IsMaximizing ? "#e8f5e9" : "#fff3e0");
                            var strokeColor = diagNode.IsOnBestPath 
                                ? "#007aff" 
                                : (node.IsPruned ? "#8e8e93" : (node.IsMaximizing ? "#34c759" : "#ff9500"));
                            var strokeWidth = diagNode.IsOnBestPath ? "3" : "2";
                            
                            <g class="@nodeClass" 
                               transform="translate(@diagNode.X.ToString(CultureInfo.InvariantCulture), @diagNode.Y.ToString(CultureInfo.InvariantCulture))"
                               @onclick="() => JumpToNode(node)"
                               style="cursor: pointer;">
                                
                                @* Node background *@
                                <rect x="0" y="0" 
                                      width="@NodeWidth" height="@NodeHeight" 
                                      rx="8" ry="8"
                                      fill="@fillColor" 
                                      stroke="@strokeColor" 
                                      stroke-width="@strokeWidth" />
                                
                                @* Best path glow effect *@
                                @if (diagNode.IsOnBestPath && !node.IsPruned) {
                                    <rect x="-2" y="-2" 
                                          width="@(NodeWidth + 4)" height="@(NodeHeight + 4)" 
                                          rx="10" ry="10"
                                          fill="none" 
                                          stroke="#007aff" 
                                          stroke-width="1"
                                          opacity="0.3" />
                                }
                                
                                @* Type badge (MAX/MIN) *@
                                <rect x="4" y="4" width="32" height="14" rx="3" 
                                      fill="@(node.IsMaximizing ? "#34c759" : "#ff9500")" />
                                <foreignObject x="4" y="4" width="32" height="14">
                                    <div xmlns="http://www.w3.org/1999/xhtml" class="svg-text svg-badge-text">
                                        @(node.IsMaximizing ? "MAX" : "MIN")
                                    </div>
                                </foreignObject>
                                
                                @* Move notation *@
                                <foreignObject x="0" y="20" width="@NodeWidth" height="18">
                                    <div xmlns="http://www.w3.org/1999/xhtml" class="svg-text svg-move-text">
                                        @node.MoveNotation
                                    </div>
                                </foreignObject>
                                
                                @* Score *@
                                @if (node.Score.HasValue) {
                                    <foreignObject x="0" y="38" width="@NodeWidth" height="16">
                                        <div xmlns="http://www.w3.org/1999/xhtml" class="svg-text svg-score-text">
                                            @FormatScore(node.Score.Value)
                                        </div>
                                    </foreignObject>
                                }
                                
                                @* Alpha/Beta values *@
                                <foreignObject x="0" y="52" width="@NodeWidth" height="14">
                                    <div xmlns="http://www.w3.org/1999/xhtml" class="svg-text svg-ab-text">
                                        α:@FormatScore(node.Alpha) β:@FormatScore(node.Beta)
                                    </div>
                                </foreignObject>
                                
                                @* Pruned badge *@
                                @if (node.IsPruned) {
                                    <rect x="@(NodeWidth - 42)" y="4" width="38" height="14" rx="3" fill="#ff3b30" />
                                    <foreignObject x="@(NodeWidth - 42)" y="4" width="38" height="14">
                                        <div xmlns="http://www.w3.org/1999/xhtml" class="svg-text svg-badge-text svg-pruned-text">
                                            PRUNED
                                        </div>
                                    </foreignObject>
                                }
                                
                                @* Best move badge *@
                                @if (node.IsBestMove && !node.IsPruned) {
                                    <rect x="@(NodeWidth - 32)" y="4" width="28" height="14" rx="3" fill="#007aff" />
                                    <foreignObject x="@(NodeWidth - 32)" y="4" width="28" height="14">
                                        <div xmlns="http://www.w3.org/1999/xhtml" class="svg-text svg-badge-text">
                                            BEST
                                        </div>
                                    </foreignObject>
                                }
                                
                                @* Current node highlight *@
                                @if (currentNode?.Id == node.Id) {
                                    <rect x="-4" y="-4" 
                                          width="@(NodeWidth + 8)" height="@(NodeHeight + 8)" 
                                          rx="12" ry="12"
                                          fill="none" 
                                          stroke="#af52de" 
                                          stroke-width="3"
                                          stroke-dasharray="5,3" />
                                }
                            </g>
                        }
                    </svg>
                </div>
                
                @* Pruning explanation panel *@
                <div class="pruning-explanation">
                    <div class="explanation-section">
                        <h4>How Alpha-Beta Pruning Works</h4>
                        <div class="explanation-items">
                            <div class="explanation-item">
                                <span class="exp-icon exp-max">MAX</span>
                                <span>Maximizing player tries to get the <strong>highest</strong> score</span>
                            </div>
                            <div class="explanation-item">
                                <span class="exp-icon exp-min">MIN</span>
                                <span>Minimizing player tries to get the <strong>lowest</strong> score</span>
                            </div>
                            <div class="explanation-item">
                                <span class="exp-icon exp-alpha">α</span>
                                <span>Alpha = best score MAX can guarantee (starts at -∞)</span>
                            </div>
                            <div class="explanation-item">
                                <span class="exp-icon exp-beta">β</span>
                                <span>Beta = best score MIN can guarantee (starts at +∞)</span>
                            </div>
                            <div class="explanation-item">
                                <span class="exp-icon exp-prune">✂</span>
                                <span>When β ≤ α, remaining branches are <strong>pruned</strong> (not explored)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        } else {
            @* Simplified tree view - list-based for performance *@
            <div class="tree-list-container">
                @{
                    var displayNodes = GetDisplayNodes();
                    visibleNodesCount = displayNodes.Count;
                }
                
                @foreach (var item in displayNodes) {
                    var node = item.Node;
                    var isCurrent = currentNode?.Id == node.Id;
                    var nodeClass = GetNodeClass(node, isCurrent);
                    
                    <div class="tree-node-row @nodeClass" style="padding-left: @(item.Depth * 24 + 12)px" @onclick="() => JumpToNode(node)">
                        <div class="node-indent">
                            @if (item.HasChildren) {
                                <button class="expand-toggle" @onclick="() => ToggleExpand(node.Id)" @onclick:stopPropagation="true">
                                    @(expandedNodes.Contains(node.Id) ? "−" : "+")
                                </button>
                            } else {
                                <span class="expand-spacer"></span>
                            }
                            <span class="tree-line">@(item.IsLast ? "└" : "├")─</span>
                        </div>
                        <div class="node-content">
                            <span class="node-type-badge @(node.IsMaximizing ? "max" : "min")">
                                @(node.IsMaximizing ? "MAX" : "MIN")
                            </span>
                            <span class="node-move-name">@node.MoveNotation</span>
                            @if (node.Score.HasValue) {
                                <span class="node-score-value">@FormatScore(node.Score.Value)</span>
                            }
                            @if (node.IsPruned) {
                                <span class="node-pruned-tag">PRUNED</span>
                            }
                            @if (node.IsBestMove) {
                                <span class="node-best-tag">BEST</span>
                            }
                            <span class="node-ab-values">α:@FormatScore(node.Alpha) β:@FormatScore(node.Beta)</span>
                            @if (item.HasChildren) {
                                <span class="node-children-count">(@node.Children.Count children)</span>
                            }
                        </div>
                    </div>
                }
                
                @if (displayNodes.Count >= maxRenderedNodes) {
                    <div class="truncation-notice">
                        Showing @maxRenderedNodes of @GetTotalVisibleCount() nodes. Increase limit or use filters to see more.
                    </div>
                }
            </div>
        }
    }
</div>

@code {
    [Parameter]
    public MiniMaxSearchResult? SearchResult { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    private enum ViewMode { BestPath, CurrentBranch, Evaluated, TreeDiagram }
    private ViewMode viewMode = ViewMode.CurrentBranch;
    private int maxVisibleDepth = 3;
    private int maxRenderedNodes = 100;
    private int visibleNodesCount = 0;
    private HashSet<int> expandedNodes = new();
    private HashSet<int> visitedNodeIds = new();
    
    private int currentStep = 0;
    private int maxSteps => SearchResult?.NodesInVisitOrder.Count ?? 0;
    private MiniMaxNode? currentNode => currentStep > 0 ? SearchResult?.NodesInVisitOrder.ElementAtOrDefault(currentStep - 1) : null;
    
    private bool isPlaying = false;
    private int speedMs = 100;
    private System.Threading.CancellationTokenSource? playbackCts;

    private record DisplayNode(MiniMaxNode Node, int Depth, bool IsLast, bool HasChildren);

    protected override void OnParametersSet() {
        if (SearchResult != null) {
            maxVisibleDepth = Math.Min(SearchResult.SearchDepth, 3);
            expandedNodes.Clear();
            expandedNodes.Add(SearchResult.RootNode.Id);
        }
    }

    private void SetViewMode(ViewMode mode) {
        viewMode = mode;
        StateHasChanged();
    }

    private void ToggleExpand(int nodeId) {
        if (expandedNodes.Contains(nodeId)) {
            expandedNodes.Remove(nodeId);
        } else {
            expandedNodes.Add(nodeId);
        }
        StateHasChanged();
    }

    private void JumpToNode(MiniMaxNode node) {
        // Find the step for this node
        if (SearchResult == null) return;
        var index = SearchResult.NodesInVisitOrder.FindIndex(n => n.Id == node.Id);
        if (index >= 0) {
            // Add all nodes up to this one to visited
            for (int i = 0; i <= index; i++) {
                visitedNodeIds.Add(SearchResult.NodesInVisitOrder[i].Id);
            }
            currentStep = index + 1;
            
            // Expand path to this node
            var current = node.Parent;
            while (current != null) {
                expandedNodes.Add(current.Id);
                current = current.Parent;
            }
            StateHasChanged();
        }
    }

    private int GetTotalVisibleCount() {
        if (SearchResult == null) return 0;
        return viewMode switch {
            ViewMode.BestPath => GetBestPathNodes().Count,
            ViewMode.CurrentBranch => GetCurrentBranchCount(),
            ViewMode.Evaluated => visitedNodeIds.Count + 1,
            _ => SearchResult.TotalNodesEvaluated
        };
    }

    private int GetCurrentBranchCount() {
        if (currentNode == null || SearchResult == null) return 1;
        int count = 0;
        var node = currentNode;
        while (node != null) {
            count++;
            node = node.Parent;
        }
        // Add siblings and their immediate children
        if (currentNode.Parent != null) {
            count += currentNode.Parent.Children.Count - 1;
        }
        return count;
    }

    private List<DisplayNode> GetDisplayNodes() {
        if (SearchResult == null) return new();
        
        var result = new List<DisplayNode>();
        var nodesToProcess = new Stack<(MiniMaxNode node, int depth, bool isLast)>();
        
        // Determine which nodes to show based on view mode
        HashSet<int> visibleIds = viewMode switch {
            ViewMode.BestPath => GetBestPathNodes(),
            ViewMode.CurrentBranch => GetCurrentBranchNodes(),
            ViewMode.Evaluated => new HashSet<int>(visitedNodeIds) { SearchResult.RootNode.Id },
            _ => new HashSet<int> { SearchResult.RootNode.Id }
        };

        nodesToProcess.Push((SearchResult.RootNode, 0, true));
        
        while (nodesToProcess.Count > 0 && result.Count < maxRenderedNodes) {
            var (node, depth, isLast) = nodesToProcess.Pop();
            
            if (!visibleIds.Contains(node.Id) && depth > 0) continue;
            if (depth > maxVisibleDepth) continue;
            
            var visibleChildren = node.Children
                .Where(c => visibleIds.Contains(c.Id) || expandedNodes.Contains(node.Id))
                .ToList();
            
            result.Add(new DisplayNode(node, depth, isLast, node.Children.Any()));
            
            if (expandedNodes.Contains(node.Id)) {
                // Add children in reverse order so they come out in correct order from stack
                for (int i = visibleChildren.Count - 1; i >= 0; i--) {
                    nodesToProcess.Push((visibleChildren[i], depth + 1, i == visibleChildren.Count - 1));
                }
            }
        }
        
        return result;
    }

    private HashSet<int> GetBestPathNodes() {
        var path = new HashSet<int>();
        if (SearchResult == null) return path;
        
        var current = SearchResult.RootNode;
        path.Add(current.Id);
        
        while (current.Children.Any()) {
            var best = current.Children.FirstOrDefault(c => c.IsBestMove);
            if (best == null) break;
            path.Add(best.Id);
            expandedNodes.Add(current.Id);
            current = best;
        }
        
        return path;
    }

    private HashSet<int> GetCurrentBranchNodes() {
        var nodes = new HashSet<int>();
        if (SearchResult == null) return nodes;
        
        nodes.Add(SearchResult.RootNode.Id);
        
        if (currentNode != null) {
            // Add path from root to current
            var pathNode = currentNode;
            while (pathNode != null) {
                nodes.Add(pathNode.Id);
                if (pathNode.Parent != null) {
                    expandedNodes.Add(pathNode.Parent.Id);
                }
                pathNode = pathNode.Parent;
            }
            
            // Add siblings of current node
            if (currentNode.Parent != null) {
                foreach (var sibling in currentNode.Parent.Children) {
                    nodes.Add(sibling.Id);
                }
            }
            
            // Add children of current node
            foreach (var child in currentNode.Children) {
                nodes.Add(child.Id);
            }
        }
        
        return nodes;
    }

    private void Reset() {
        StopPlayback();
        currentStep = 0;
        visitedNodeIds.Clear();
        StateHasChanged();
    }

    private void StepForward() {
        if (currentStep < maxSteps) {
            currentStep++;
            if (currentStep > 0 && SearchResult != null) {
                var node = SearchResult.NodesInVisitOrder[currentStep - 1];
                visitedNodeIds.Add(node.Id);
                // Auto-expand parent nodes
                var parent = node.Parent;
                while (parent != null) {
                    expandedNodes.Add(parent.Id);
                    parent = parent.Parent;
                }
            }
            StateHasChanged();
        }
    }

    private void StepBack() {
        if (currentStep > 0) {
            if (SearchResult != null) {
                var node = SearchResult.NodesInVisitOrder[currentStep - 1];
                visitedNodeIds.Remove(node.Id);
            }
            currentStep--;
            StateHasChanged();
        }
    }

    private void SkipToEnd() {
        StopPlayback();
        if (SearchResult != null) {
            while (currentStep < maxSteps) {
                var node = SearchResult.NodesInVisitOrder[currentStep];
                visitedNodeIds.Add(node.Id);
                currentStep++;
            }
        }
        StateHasChanged();
    }

    private async Task Play() {
        if (isPlaying) return;
        
        isPlaying = true;
        playbackCts = new System.Threading.CancellationTokenSource();
        StateHasChanged();
        
        try {
            while (currentStep < maxSteps && !playbackCts.Token.IsCancellationRequested) {
                StepForward();
                await Task.Delay(speedMs, playbackCts.Token);
            }
        } catch (TaskCanceledException) { }
        
        isPlaying = false;
        StateHasChanged();
    }

    private void Pause() {
        StopPlayback();
        StateHasChanged();
    }

    private void StopPlayback() {
        playbackCts?.Cancel();
        playbackCts?.Dispose();
        playbackCts = null;
        isPlaying = false;
    }

    private string FormatScore(int score) {
        if (score == int.MaxValue) return "+∞";
        if (score == int.MinValue) return "-∞";
        return score.ToString();
    }

    private string GetPieceSymbol(PieceType type, PieceColor color) {
        return (type, color) switch {
            (PieceType.King, PieceColor.White) => "♔",
            (PieceType.Queen, PieceColor.White) => "♕",
            (PieceType.Rook, PieceColor.White) => "♖",
            (PieceType.Bishop, PieceColor.White) => "♗",
            (PieceType.Knight, PieceColor.White) => "♘",
            (PieceType.Pawn, PieceColor.White) => "♙",
            (PieceType.King, PieceColor.Black) => "♚",
            (PieceType.Queen, PieceColor.Black) => "♛",
            (PieceType.Rook, PieceColor.Black) => "♜",
            (PieceType.Bishop, PieceColor.Black) => "♝",
            (PieceType.Knight, PieceColor.Black) => "♞",
            (PieceType.Pawn, PieceColor.Black) => "♟",
            _ => ""
        };
    }

    private string GetNodeClass(MiniMaxNode node, bool isCurrent) {
        var classes = new List<string>();
        if (isCurrent) classes.Add("current");
        if (node.IsPruned) classes.Add("pruned");
        else if (node.IsBestMove) classes.Add("best-move");
        else if (node.IsMaximizing) classes.Add("maximizing");
        else classes.Add("minimizing");
        return string.Join(" ", classes);
    }

    // ============== Tree Diagram Methods ==============
    
    private record TreeDiagramNode(MiniMaxNode Node, double X, double Y, bool IsOnBestPath);
    private record TreeDiagramEdge(MiniMaxNode Parent, MiniMaxNode Child, double X1, double Y1, double X2, double Y2, bool IsOnBestPath, bool IsPruned);

    // Constants for tree layout
    private const double NodeWidth = 100;
    private const double NodeHeight = 70;
    private const double VerticalSpacing = 150;
    private const double HorizontalSpacing = 20;
    private const double TreePadding = 50;

    /// <summary>
    /// Gets nodes optimized for tree diagram display - best path plus pruning examples.
    /// Simple BFS from root, collecting nodes up to maxVisibleDepth.
    /// </summary>
    private List<MiniMaxNode> GetTreeDiagramNodes() {
        if (SearchResult == null) return new();
        
        var result = new Dictionary<int, MiniMaxNode>(); // Use ID as key to avoid duplicates
        var root = SearchResult.RootNode;
        
        // BFS from root to collect all nodes up to maxVisibleDepth
        var queue = new Queue<MiniMaxNode>();
        queue.Enqueue(root);
        result[root.Id] = root;
        
        while (queue.Count > 0) {
            var node = queue.Dequeue();
            
            // Stop expanding if we've reached max depth
            if (node.Depth >= maxVisibleDepth) continue;
            
            // Add children (limit to prevent explosion)
            // Prioritize: best move first, then pruned (to show pruning), then by visit order
            var childrenToAdd = node.Children
                .OrderByDescending(c => c.IsBestMove)
                .ThenByDescending(c => c.IsPruned)
                .ThenBy(c => c.VisitOrder)
                .Take(5) // Max 5 children per node for readability
                .ToList();
            
            foreach (var child in childrenToAdd) {
                if (!result.ContainsKey(child.Id)) {
                    result[child.Id] = child;
                    queue.Enqueue(child);
                }
            }
        }
        
        return result.Values.OrderBy(n => n.Depth).ThenBy(n => n.VisitOrder).ToList();
    }

    /// <summary>
    /// Calculates the layout positions for all nodes in the tree diagram.
    /// Simple grid-based layout: nodes at each depth are spread horizontally.
    /// </summary>
    private (List<TreeDiagramNode> nodes, List<TreeDiagramEdge> edges, double width, double height) CalculateTreeLayout() {
        var diagramNodes = new List<TreeDiagramNode>();
        var diagramEdges = new List<TreeDiagramEdge>();
        
        if (SearchResult == null) return (diagramNodes, diagramEdges, 0, 0);
        
        var nodesToDisplay = GetTreeDiagramNodes();
        if (!nodesToDisplay.Any()) return (diagramNodes, diagramEdges, 0, 0);
        
        var nodeIds = new HashSet<int>(nodesToDisplay.Select(n => n.Id));
        var bestPathIds = GetBestPathNodeIds();
        
        // Group nodes by their actual depth
        var nodesByDepth = nodesToDisplay
            .GroupBy(n => n.Depth)
            .OrderBy(g => g.Key)
            .ToList();
        
        // Get min depth to normalize Y positions
        int minDepth = nodesByDepth.First().Key;
        
        // Simple layout: spread nodes horizontally at each depth level
        var positions = new Dictionary<int, (double x, double y)>();
        
        foreach (var depthGroup in nodesByDepth) {
            int depth = depthGroup.Key;
            var nodesAtDepth = depthGroup.OrderBy(n => n.VisitOrder).ToList();
            
            // Y position based on depth
            double y = TreePadding + (depth - minDepth) * VerticalSpacing;
            
            // Spread nodes horizontally with spacing
            for (int i = 0; i < nodesAtDepth.Count; i++) {
                var node = nodesAtDepth[i];
                double x = TreePadding + i * (NodeWidth + HorizontalSpacing);
                positions[node.Id] = (x, y);
            }
        }
        
        // Calculate dimensions
        double maxX = positions.Values.Any() ? positions.Values.Max(p => p.x) + NodeWidth + TreePadding : TreePadding * 2;
        double maxY = positions.Values.Any() ? positions.Values.Max(p => p.y) + NodeHeight + TreePadding : TreePadding * 2;
        
        // Create diagram nodes
        foreach (var node in nodesToDisplay) {
            if (positions.TryGetValue(node.Id, out var pos)) {
                var isOnBestPath = bestPathIds.Contains(node.Id);
                diagramNodes.Add(new TreeDiagramNode(node, pos.x, pos.y, isOnBestPath));
            }
        }
        
        // Create edges - connect each node to its parent if both are in our display set
        foreach (var node in nodesToDisplay) {
            if (node.Parent != null && 
                positions.TryGetValue(node.Parent.Id, out var parentPos) && 
                positions.TryGetValue(node.Id, out var childPos) &&
                nodeIds.Contains(node.Parent.Id)) {
                
                var isOnBestPath = bestPathIds.Contains(node.Id) && bestPathIds.Contains(node.Parent.Id);
                diagramEdges.Add(new TreeDiagramEdge(
                    node.Parent, 
                    node, 
                    parentPos.x + NodeWidth / 2, 
                    parentPos.y + NodeHeight,
                    childPos.x + NodeWidth / 2, 
                    childPos.y,
                    isOnBestPath,
                    node.IsPruned
                ));
            }
        }
        
        return (diagramNodes, diagramEdges, maxX, maxY);
    }

    /// <summary>
    /// Gets the IDs of nodes on the best path.
    /// </summary>
    private HashSet<int> GetBestPathNodeIds() {
        var ids = new HashSet<int>();
        if (SearchResult == null) return ids;
        
        var current = SearchResult.RootNode;
        ids.Add(current.Id);
        
        while (current.Children.Any()) {
            var best = current.Children.FirstOrDefault(c => c.IsBestMove);
            if (best == null) {
                best = current.IsMaximizing 
                    ? current.Children.OrderByDescending(c => c.Score ?? int.MinValue).FirstOrDefault()
                    : current.Children.OrderBy(c => c.Score ?? int.MaxValue).FirstOrDefault();
            }
            if (best == null) break;
            ids.Add(best.Id);
            current = best;
        }
        
        return ids;
    }

    /// <summary>
    /// Gets the CSS class for a tree diagram node.
    /// </summary>
    private string GetTreeNodeClass(MiniMaxNode node, bool isOnBestPath) {
        var classes = new List<string> { "tree-node" };
        
        if (node.IsMaximizing) classes.Add("tree-node-max");
        else classes.Add("tree-node-min");
        
        if (isOnBestPath) classes.Add("tree-node-best-path");
        if (node.IsPruned) classes.Add("tree-node-pruned");
        if (node.IsBestMove) classes.Add("tree-node-best");
        if (currentNode?.Id == node.Id) classes.Add("tree-node-current");
        
        return string.Join(" ", classes);
    }

    /// <summary>
    /// Gets the CSS class for a tree diagram edge.
    /// </summary>
    private string GetTreeEdgeClass(TreeDiagramEdge edge) {
        var classes = new List<string> { "tree-edge" };
        
        if (edge.IsOnBestPath) classes.Add("tree-edge-best-path");
        if (edge.IsPruned) classes.Add("tree-edge-pruned");
        
        return string.Join(" ", classes);
    }
}

<style>
    .minimax-fullscreen {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: #fafafa;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 16px 24px;
        background: white;
        border-bottom: 1px solid #e5e5e5;
    }

    .header-left h1 {
        margin: 0 0 8px 0;
        font-size: 20px;
        font-weight: 600;
        color: #1d1d1f;
    }

    .stats-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }

    .stat-chip {
        display: flex;
        flex-direction: column;
        padding: 4px 10px;
        background: #f5f5f7;
        border-radius: 8px;
    }

    .stat-chip.stat-active { background: #007aff; }
    .stat-chip.stat-active .stat-label,
    .stat-chip.stat-active .stat-value { color: white; }
    .stat-label { font-size: 9px; color: #86868b; text-transform: uppercase; }
    .stat-value { font-size: 14px; font-weight: 600; color: #1d1d1f; }

    .close-btn {
        background: none;
        border: none;
        padding: 8px;
        cursor: pointer;
        color: #86868b;
        border-radius: 8px;
    }
    .close-btn:hover { background: #f5f5f7; color: #1d1d1f; }

    .empty-state {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #86868b;
    }

    .controls-bar {
        display: flex;
        align-items: center;
        padding: 10px 24px;
        background: white;
        border-bottom: 1px solid #e5e5e5;
        gap: 16px;
        flex-wrap: wrap;
    }

    .playback-controls {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .control-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px; height: 32px;
        border: none;
        background: #f5f5f7;
        border-radius: 6px;
        cursor: pointer;
        color: #1d1d1f;
    }
    .control-btn:hover:not(:disabled) { background: #e5e5e5; }
    .control-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .control-btn-primary {
        width: 40px; height: 40px;
        background: #007aff;
        color: white;
        border-radius: 50%;
    }
    .control-btn-primary:hover:not(:disabled) { background: #0056b3; }

    .view-modes {
        display: flex;
        background: #f5f5f7;
        border-radius: 6px;
        padding: 3px;
    }

    .mode-btn {
        padding: 5px 12px;
        border: none;
        background: transparent;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        color: #86868b;
        cursor: pointer;
    }
    .mode-btn:hover { color: #1d1d1f; }
    .mode-btn.active {
        background: white;
        color: #007aff;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .depth-control, .limit-control, .speed-slider {
        display: flex;
        align-items: center;
        gap: 6px;
    }
    .depth-label, .speed-label, .speed-value {
        font-size: 12px;
        color: #86868b;
    }
    .depth-select {
        padding: 4px 8px;
        border: 1px solid #e5e5e5;
        border-radius: 4px;
        font-size: 12px;
    }
    .speed-slider input[type="range"] {
        width: 80px;
        accent-color: #007aff;
    }
    .progress-display { margin-left: auto; }
    .progress-text { font-size: 12px; color: #86868b; }

    .legend-bar {
        display: flex;
        justify-content: center;
        gap: 20px;
        padding: 8px 24px;
        background: #f5f5f7;
        font-size: 11px;
    }
    .legend-item { display: flex; align-items: center; gap: 4px; color: #86868b; }
    .legend-dot { width: 8px; height: 8px; border-radius: 2px; }
    .legend-max { background: #34c759; }
    .legend-min { background: #ff9500; }
    .legend-pruned { background: #8e8e93; }
    .legend-best { background: #007aff; }
    .legend-current { background: #af52de; }

    .detail-panel {
        display: flex;
        gap: 20px;
        padding: 16px 24px;
        background: white;
        border-bottom: 1px solid #e5e5e5;
        align-items: center;
        justify-content: center;
    }

    .detail-board {
        display: flex;
        flex-direction: column;
        border: 2px solid #1d1d1f;
        border-radius: 4px;
        overflow: hidden;
    }
    .detail-row { display: flex; }
    .detail-cell {
        width: 28px; height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
    }
    .detail-cell.light { background: #f0d9b5; }
    .detail-cell.dark { background: #b58863; }
    .detail-cell.from { background: #ff9500 !important; }
    .detail-cell.to { background: #007aff !important; }
    .white-piece { color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    .black-piece { color: #000; }

    .detail-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    .detail-move { font-size: 24px; font-weight: 700; color: #1d1d1f; }
    .detail-type {
        font-size: 11px; font-weight: 600;
        padding: 3px 8px; border-radius: 4px;
        width: fit-content;
    }
    .detail-type.type-max { background: #d4edda; color: #155724; }
    .detail-type.type-min { background: #fff3cd; color: #856404; }
    .detail-score { font-size: 18px; font-weight: 600; color: #007aff; }
    .detail-ab { font-size: 12px; color: #86868b; font-family: monospace; }
    .detail-pruned {
        font-size: 11px; font-weight: 600;
        color: white; background: #8e8e93;
        padding: 2px 8px; border-radius: 4px;
        width: fit-content;
    }

    .tree-list-container {
        flex: 1;
        overflow: auto;
        padding: 8px 0;
        background: white;
    }

    .tree-node-row {
        display: flex;
        align-items: center;
        padding: 6px 12px;
        cursor: pointer;
        border-left: 3px solid transparent;
        transition: background 0.15s;
    }
    .tree-node-row:hover { background: #f5f5f7; }
    .tree-node-row.current {
        background: #f0f0ff;
        border-left-color: #af52de;
    }
    .tree-node-row.best-move { border-left-color: #007aff; }
    .tree-node-row.pruned { opacity: 0.5; }

    .node-indent {
        display: flex;
        align-items: center;
        color: #c7c7cc;
        font-family: monospace;
        font-size: 12px;
        margin-right: 8px;
    }
    .expand-toggle {
        width: 18px; height: 18px;
        border: 1px solid #d1d1d6;
        background: white;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
        color: #007aff;
        margin-right: 4px;
    }
    .expand-toggle:hover { background: #f5f5f7; }
    .expand-spacer { width: 22px; }
    .tree-line { color: #d1d1d6; }

    .node-content {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
    }
    .node-type-badge {
        font-size: 9px;
        font-weight: 600;
        padding: 2px 6px;
        border-radius: 3px;
    }
    .node-type-badge.max { background: #d4edda; color: #155724; }
    .node-type-badge.min { background: #fff3cd; color: #856404; }
    .node-move-name { font-weight: 600; color: #1d1d1f; }
    .node-score-value { color: #007aff; font-weight: 600; }
    .node-pruned-tag {
        font-size: 9px; font-weight: 600;
        color: white; background: #8e8e93;
        padding: 1px 5px; border-radius: 3px;
    }
    .node-best-tag {
        font-size: 9px; font-weight: 600;
        color: white; background: #007aff;
        padding: 1px 5px; border-radius: 3px;
    }
    .node-ab-values {
        font-size: 11px;
        color: #86868b;
        font-family: monospace;
    }
    .node-children-count {
        font-size: 11px;
        color: #86868b;
    }

    .truncation-notice {
        padding: 12px 24px;
        text-align: center;
        color: #86868b;
        font-size: 12px;
        background: #f5f5f7;
        border-top: 1px solid #e5e5e5;
    }

    /* ============== Tree Diagram Styles ============== */
    
    .tree-diagram-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: white;
        overflow: hidden;
    }

    .tree-diagram-info {
        padding: 12px 24px;
        background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
        border-bottom: 1px solid #e5e5e5;
    }

    .tree-diagram-info p {
        margin: 0;
        font-size: 13px;
        color: #1d1d1f;
        line-height: 1.5;
    }

    .tree-diagram-scroll {
        flex: 1;
        overflow: auto;
        padding: 20px;
        background: 
            linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px),
            linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px);
        background-size: 20px 20px;
    }

    .tree-svg {
        display: block;
        min-width: 100%;
    }

    /* Tree edges (connections) */
    .tree-edge {
        fill: none;
        stroke: #c7c7cc;
        stroke-width: 2;
        transition: stroke 0.2s, stroke-width 0.2s;
    }

    .tree-edge-best-path {
        stroke: #007aff;
        stroke-width: 3;
    }

    .tree-edge-pruned {
        stroke: #ff3b30;
        stroke-width: 2;
        stroke-dasharray: 8, 4;
        opacity: 0.7;
    }

    /* Tree nodes */
    .tree-node {
        transition: filter 0.15s;
    }

    .tree-node:hover {
        filter: drop-shadow(0 4px 12px rgba(0,0,0,0.25));
    }

    .tree-node-max rect:first-of-type {
        fill: #e8f5e9;
    }

    .tree-node-min rect:first-of-type {
        fill: #fff3e0;
    }

    .tree-node-best-path rect:first-of-type {
        stroke: #007aff !important;
        stroke-width: 3 !important;
    }

    .tree-node-pruned {
        opacity: 0.7;
    }

    .tree-node-pruned rect:first-of-type {
        fill: url(#prunedPattern) !important;
        stroke: #8e8e93 !important;
    }

    .tree-node-current {
        animation: pulse-current 1.5s ease-in-out infinite;
    }

    @@keyframes pulse-current {
        0%, 100% { filter: drop-shadow(0 0 8px rgba(175, 82, 222, 0.5)); }
        50% { filter: drop-shadow(0 0 16px rgba(175, 82, 222, 0.8)); }
    }

    /* Pruning indicator */
    .prune-indicator {
        animation: prune-appear 0.3s ease-out;
    }

    @@keyframes prune-appear {
        from { transform: scale(0); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }

    /* Pruning explanation panel */
    .pruning-explanation {
        padding: 16px 24px;
        background: #f5f5f7;
        border-top: 1px solid #e5e5e5;
    }

    .explanation-section h4 {
        margin: 0 0 12px 0;
        font-size: 14px;
        font-weight: 600;
        color: #1d1d1f;
    }

    .explanation-items {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
    }

    .explanation-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #1d1d1f;
    }

    .exp-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 28px;
        height: 20px;
        padding: 0 6px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: 700;
    }

    .exp-icon.exp-max {
        background: #34c759;
        color: white;
    }

    .exp-icon.exp-min {
        background: #ff9500;
        color: white;
    }

    .exp-icon.exp-alpha {
        background: #007aff;
        color: white;
        font-family: serif;
        font-style: italic;
    }

    .exp-icon.exp-beta {
        background: #5856d6;
        color: white;
        font-family: serif;
        font-style: italic;
    }

    .exp-icon.exp-prune {
        background: #ff3b30;
        color: white;
        font-size: 14px;
    }

    /* SVG text styling via foreignObject */
    .svg-text {
        user-select: none;
        pointer-events: none;
        text-align: center;
        line-height: 1;
        white-space: nowrap;
        overflow: hidden;
    }

    .svg-badge-text {
        font-size: 8px;
        font-weight: bold;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }

    .svg-pruned-text {
        font-size: 7px;
    }

    .svg-move-text {
        font-size: 11px;
        font-weight: 600;
        color: #1d1d1f;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }

    .svg-score-text {
        font-size: 12px;
        font-weight: bold;
        color: #007aff;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }

    .svg-ab-text {
        font-size: 8px;
        font-family: monospace;
        color: #86868b;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }

    .svg-prune-icon {
        font-size: 14px;
        font-weight: bold;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
    }

    /* Responsive adjustments */
    @@media (max-width: 768px) {
        .explanation-items {
            flex-direction: column;
            gap: 8px;
        }
        
        .tree-diagram-scroll {
            padding: 10px;
        }
    }
</style>
