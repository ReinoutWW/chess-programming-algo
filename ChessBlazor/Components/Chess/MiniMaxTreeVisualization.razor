@namespace ChessBlazor.Components.Chess

@using global::Chess.Programming.Ago.ChessEngines
@using global::Chess.Programming.Ago.Pieces
@using Microsoft.AspNetCore.Components.Web.Virtualization

<div class="minimax-fullscreen">
    <div class="header">
        <div class="header-left">
            <h1>Minimax Algorithm</h1>
            @if (SearchResult != null) {
                <div class="stats-row">
                    <div class="stat-chip">
                        <span class="stat-label">Depth</span>
                        <span class="stat-value">@SearchResult.SearchDepth</span>
                    </div>
                    <div class="stat-chip">
                        <span class="stat-label">Total Nodes</span>
                        <span class="stat-value">@SearchResult.TotalNodesEvaluated.ToString("N0")</span>
                    </div>
                    <div class="stat-chip">
                        <span class="stat-label">Visible</span>
                        <span class="stat-value">@visibleNodesCount.ToString("N0")</span>
                    </div>
                    <div class="stat-chip">
                        <span class="stat-label">Pruned</span>
                        <span class="stat-value">@SearchResult.NodesPruned.ToString("N0")</span>
                    </div>
                    <div class="stat-chip @(SearchResult.AlphaBetaEnabled ? "stat-active" : "")">
                        <span class="stat-label">Alpha-Beta</span>
                        <span class="stat-value">@(SearchResult.AlphaBetaEnabled ? "ON" : "OFF")</span>
                    </div>
                </div>
            }
        </div>
        <button class="close-btn" @onclick="OnClose">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
        </button>
    </div>

    @if (SearchResult == null) {
        <div class="empty-state">
            <h2>No Search Data</h2>
            <p>Make a move with the AI player to visualize the algorithm</p>
        </div>
    } else {
        <div class="controls-bar">
            <div class="playback-controls">
                <button class="control-btn" @onclick="Reset" disabled="@(currentStep == 0)" title="Reset">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                    </svg>
                </button>
                <button class="control-btn" @onclick="StepBack" disabled="@(currentStep == 0)" title="Back">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>
                    </svg>
                </button>
                @if (isPlaying) {
                    <button class="control-btn control-btn-primary" @onclick="Pause" title="Pause">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                } else {
                    <button class="control-btn control-btn-primary" @onclick="Play" disabled="@(currentStep >= maxSteps)" title="Play">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </button>
                }
                <button class="control-btn" @onclick="StepForward" disabled="@(currentStep >= maxSteps)" title="Forward">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M13 6v12l8.5-6L13 6zM4 18l8.5-6L4 6v12z"/>
                    </svg>
                </button>
                <button class="control-btn" @onclick="SkipToEnd" disabled="@(currentStep >= maxSteps)" title="End">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                    </svg>
                </button>
            </div>

            <div class="view-modes">
                <button class="mode-btn @(viewMode == ViewMode.BestPath ? "active" : "")" @onclick="() => SetViewMode(ViewMode.BestPath)">
                    Best Path
                </button>
                <button class="mode-btn @(viewMode == ViewMode.CurrentBranch ? "active" : "")" @onclick="() => SetViewMode(ViewMode.CurrentBranch)">
                    Current Branch
                </button>
                <button class="mode-btn @(viewMode == ViewMode.Evaluated ? "active" : "")" @onclick="() => SetViewMode(ViewMode.Evaluated)">
                    Evaluated (@visitedNodeIds.Count)
                </button>
            </div>

            <div class="depth-control">
                <span class="depth-label">Depth:</span>
                <select @bind="maxVisibleDepth" class="depth-select">
                    @for (int d = 1; d <= Math.Min(SearchResult.SearchDepth, 5); d++) {
                        <option value="@d">@d</option>
                    }
                </select>
            </div>

            <div class="limit-control">
                <span class="depth-label">Max nodes:</span>
                <select @bind="maxRenderedNodes" class="depth-select">
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="200">200</option>
                    <option value="500">500</option>
                </select>
            </div>

            <div class="speed-slider">
                <span class="speed-label">Speed</span>
                <input type="range" min="20" max="500" step="20" @bind="speedMs" @bind:event="oninput" />
                <span class="speed-value">@speedMs ms</span>
            </div>

            <div class="progress-display">
                <span class="progress-text">Step @currentStep / @maxSteps</span>
            </div>
        </div>

        <div class="legend-bar">
            <div class="legend-item"><div class="legend-dot legend-max"></div><span>MAX</span></div>
            <div class="legend-item"><div class="legend-dot legend-min"></div><span>MIN</span></div>
            <div class="legend-item"><div class="legend-dot legend-pruned"></div><span>Pruned</span></div>
            <div class="legend-item"><div class="legend-dot legend-best"></div><span>Best</span></div>
            <div class="legend-item"><div class="legend-dot legend-current"></div><span>Current</span></div>
        </div>

        @* Current node detail panel *@
        @if (currentNode != null) {
            <div class="detail-panel">
                <div class="detail-board">
                    @if (currentNode.BoardState != null) {
                        @for (int row = 0; row < 8; row++) {
                            <div class="detail-row">
                                @for (int col = 0; col < 8; col++) {
                                    var isLight = (row + col) % 2 == 0;
                                    var piece = currentNode.BoardState[row, col];
                                    var isFrom = currentNode.Move?.From.Row == row && currentNode.Move?.From.Column == col;
                                    var isTo = currentNode.Move?.To.Row == row && currentNode.Move?.To.Column == col;
                                    <div class="detail-cell @(isLight ? "light" : "dark") @(isFrom ? "from" : "") @(isTo ? "to" : "")">
                                        @if (piece != null) {
                                            <span class="@(piece.Color == PieceColor.White ? "white-piece" : "black-piece")">
                                                @GetPieceSymbol(piece.Type, piece.Color)
                                            </span>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                </div>
                <div class="detail-info">
                    <div class="detail-move">@currentNode.MoveNotation</div>
                    <div class="detail-type @(currentNode.IsMaximizing ? "type-max" : "type-min")">
                        @(currentNode.IsMaximizing ? "MAXIMIZING" : "MINIMIZING")
                    </div>
                    @if (currentNode.Score.HasValue) {
                        <div class="detail-score">Score: @FormatScore(currentNode.Score.Value)</div>
                    }
                    <div class="detail-ab">α: @FormatScore(currentNode.Alpha) | β: @FormatScore(currentNode.Beta)</div>
                    @if (currentNode.IsPruned) {
                        <div class="detail-pruned">PRUNED</div>
                    }
                </div>
            </div>
        }

        @* Simplified tree view - list-based for performance *@
        <div class="tree-list-container">
            @{
                var displayNodes = GetDisplayNodes();
                visibleNodesCount = displayNodes.Count;
            }
            
            @foreach (var item in displayNodes) {
                var node = item.Node;
                var isCurrent = currentNode?.Id == node.Id;
                var nodeClass = GetNodeClass(node, isCurrent);
                
                <div class="tree-node-row @nodeClass" style="padding-left: @(item.Depth * 24 + 12)px" @onclick="() => JumpToNode(node)">
                    <div class="node-indent">
                        @if (item.HasChildren) {
                            <button class="expand-toggle" @onclick="() => ToggleExpand(node.Id)" @onclick:stopPropagation="true">
                                @(expandedNodes.Contains(node.Id) ? "−" : "+")
                            </button>
                        } else {
                            <span class="expand-spacer"></span>
                        }
                        <span class="tree-line">@(item.IsLast ? "└" : "├")─</span>
                    </div>
                    <div class="node-content">
                        <span class="node-type-badge @(node.IsMaximizing ? "max" : "min")">
                            @(node.IsMaximizing ? "MAX" : "MIN")
                        </span>
                        <span class="node-move-name">@node.MoveNotation</span>
                        @if (node.Score.HasValue) {
                            <span class="node-score-value">@FormatScore(node.Score.Value)</span>
                        }
                        @if (node.IsPruned) {
                            <span class="node-pruned-tag">PRUNED</span>
                        }
                        @if (node.IsBestMove) {
                            <span class="node-best-tag">BEST</span>
                        }
                        <span class="node-ab-values">α:@FormatScore(node.Alpha) β:@FormatScore(node.Beta)</span>
                        @if (item.HasChildren) {
                            <span class="node-children-count">(@node.Children.Count children)</span>
                        }
                    </div>
                </div>
            }
            
            @if (displayNodes.Count >= maxRenderedNodes) {
                <div class="truncation-notice">
                    Showing @maxRenderedNodes of @GetTotalVisibleCount() nodes. Increase limit or use filters to see more.
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter]
    public MiniMaxSearchResult? SearchResult { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    private enum ViewMode { BestPath, CurrentBranch, Evaluated }
    private ViewMode viewMode = ViewMode.CurrentBranch;
    private int maxVisibleDepth = 3;
    private int maxRenderedNodes = 100;
    private int visibleNodesCount = 0;
    private HashSet<int> expandedNodes = new();
    private HashSet<int> visitedNodeIds = new();
    
    private int currentStep = 0;
    private int maxSteps => SearchResult?.NodesInVisitOrder.Count ?? 0;
    private MiniMaxNode? currentNode => currentStep > 0 ? SearchResult?.NodesInVisitOrder.ElementAtOrDefault(currentStep - 1) : null;
    
    private bool isPlaying = false;
    private int speedMs = 100;
    private System.Threading.CancellationTokenSource? playbackCts;

    private record DisplayNode(MiniMaxNode Node, int Depth, bool IsLast, bool HasChildren);

    protected override void OnParametersSet() {
        if (SearchResult != null) {
            maxVisibleDepth = Math.Min(SearchResult.SearchDepth, 3);
            expandedNodes.Clear();
            expandedNodes.Add(SearchResult.RootNode.Id);
        }
    }

    private void SetViewMode(ViewMode mode) {
        viewMode = mode;
        StateHasChanged();
    }

    private void ToggleExpand(int nodeId) {
        if (expandedNodes.Contains(nodeId)) {
            expandedNodes.Remove(nodeId);
        } else {
            expandedNodes.Add(nodeId);
        }
        StateHasChanged();
    }

    private void JumpToNode(MiniMaxNode node) {
        // Find the step for this node
        if (SearchResult == null) return;
        var index = SearchResult.NodesInVisitOrder.FindIndex(n => n.Id == node.Id);
        if (index >= 0) {
            // Add all nodes up to this one to visited
            for (int i = 0; i <= index; i++) {
                visitedNodeIds.Add(SearchResult.NodesInVisitOrder[i].Id);
            }
            currentStep = index + 1;
            
            // Expand path to this node
            var current = node.Parent;
            while (current != null) {
                expandedNodes.Add(current.Id);
                current = current.Parent;
            }
            StateHasChanged();
        }
    }

    private int GetTotalVisibleCount() {
        if (SearchResult == null) return 0;
        return viewMode switch {
            ViewMode.BestPath => GetBestPathNodes().Count,
            ViewMode.CurrentBranch => GetCurrentBranchCount(),
            ViewMode.Evaluated => visitedNodeIds.Count + 1,
            _ => SearchResult.TotalNodesEvaluated
        };
    }

    private int GetCurrentBranchCount() {
        if (currentNode == null || SearchResult == null) return 1;
        int count = 0;
        var node = currentNode;
        while (node != null) {
            count++;
            node = node.Parent;
        }
        // Add siblings and their immediate children
        if (currentNode.Parent != null) {
            count += currentNode.Parent.Children.Count - 1;
        }
        return count;
    }

    private List<DisplayNode> GetDisplayNodes() {
        if (SearchResult == null) return new();
        
        var result = new List<DisplayNode>();
        var nodesToProcess = new Stack<(MiniMaxNode node, int depth, bool isLast)>();
        
        // Determine which nodes to show based on view mode
        HashSet<int> visibleIds = viewMode switch {
            ViewMode.BestPath => GetBestPathNodes(),
            ViewMode.CurrentBranch => GetCurrentBranchNodes(),
            ViewMode.Evaluated => new HashSet<int>(visitedNodeIds) { SearchResult.RootNode.Id },
            _ => new HashSet<int> { SearchResult.RootNode.Id }
        };

        nodesToProcess.Push((SearchResult.RootNode, 0, true));
        
        while (nodesToProcess.Count > 0 && result.Count < maxRenderedNodes) {
            var (node, depth, isLast) = nodesToProcess.Pop();
            
            if (!visibleIds.Contains(node.Id) && depth > 0) continue;
            if (depth > maxVisibleDepth) continue;
            
            var visibleChildren = node.Children
                .Where(c => visibleIds.Contains(c.Id) || expandedNodes.Contains(node.Id))
                .ToList();
            
            result.Add(new DisplayNode(node, depth, isLast, node.Children.Any()));
            
            if (expandedNodes.Contains(node.Id)) {
                // Add children in reverse order so they come out in correct order from stack
                for (int i = visibleChildren.Count - 1; i >= 0; i--) {
                    nodesToProcess.Push((visibleChildren[i], depth + 1, i == visibleChildren.Count - 1));
                }
            }
        }
        
        return result;
    }

    private HashSet<int> GetBestPathNodes() {
        var path = new HashSet<int>();
        if (SearchResult == null) return path;
        
        var current = SearchResult.RootNode;
        path.Add(current.Id);
        
        while (current.Children.Any()) {
            var best = current.Children.FirstOrDefault(c => c.IsBestMove);
            if (best == null) break;
            path.Add(best.Id);
            expandedNodes.Add(current.Id);
            current = best;
        }
        
        return path;
    }

    private HashSet<int> GetCurrentBranchNodes() {
        var nodes = new HashSet<int>();
        if (SearchResult == null) return nodes;
        
        nodes.Add(SearchResult.RootNode.Id);
        
        if (currentNode != null) {
            // Add path from root to current
            var pathNode = currentNode;
            while (pathNode != null) {
                nodes.Add(pathNode.Id);
                if (pathNode.Parent != null) {
                    expandedNodes.Add(pathNode.Parent.Id);
                }
                pathNode = pathNode.Parent;
            }
            
            // Add siblings of current node
            if (currentNode.Parent != null) {
                foreach (var sibling in currentNode.Parent.Children) {
                    nodes.Add(sibling.Id);
                }
            }
            
            // Add children of current node
            foreach (var child in currentNode.Children) {
                nodes.Add(child.Id);
            }
        }
        
        return nodes;
    }

    private void Reset() {
        StopPlayback();
        currentStep = 0;
        visitedNodeIds.Clear();
        StateHasChanged();
    }

    private void StepForward() {
        if (currentStep < maxSteps) {
            currentStep++;
            if (currentStep > 0 && SearchResult != null) {
                var node = SearchResult.NodesInVisitOrder[currentStep - 1];
                visitedNodeIds.Add(node.Id);
                // Auto-expand parent nodes
                var parent = node.Parent;
                while (parent != null) {
                    expandedNodes.Add(parent.Id);
                    parent = parent.Parent;
                }
            }
            StateHasChanged();
        }
    }

    private void StepBack() {
        if (currentStep > 0) {
            if (SearchResult != null) {
                var node = SearchResult.NodesInVisitOrder[currentStep - 1];
                visitedNodeIds.Remove(node.Id);
            }
            currentStep--;
            StateHasChanged();
        }
    }

    private void SkipToEnd() {
        StopPlayback();
        if (SearchResult != null) {
            while (currentStep < maxSteps) {
                var node = SearchResult.NodesInVisitOrder[currentStep];
                visitedNodeIds.Add(node.Id);
                currentStep++;
            }
        }
        StateHasChanged();
    }

    private async Task Play() {
        if (isPlaying) return;
        
        isPlaying = true;
        playbackCts = new System.Threading.CancellationTokenSource();
        StateHasChanged();
        
        try {
            while (currentStep < maxSteps && !playbackCts.Token.IsCancellationRequested) {
                StepForward();
                await Task.Delay(speedMs, playbackCts.Token);
            }
        } catch (TaskCanceledException) { }
        
        isPlaying = false;
        StateHasChanged();
    }

    private void Pause() {
        StopPlayback();
        StateHasChanged();
    }

    private void StopPlayback() {
        playbackCts?.Cancel();
        playbackCts?.Dispose();
        playbackCts = null;
        isPlaying = false;
    }

    private string FormatScore(int score) {
        if (score == int.MaxValue) return "+∞";
        if (score == int.MinValue) return "-∞";
        return score.ToString();
    }

    private string GetPieceSymbol(PieceType type, PieceColor color) {
        return (type, color) switch {
            (PieceType.King, PieceColor.White) => "♔",
            (PieceType.Queen, PieceColor.White) => "♕",
            (PieceType.Rook, PieceColor.White) => "♖",
            (PieceType.Bishop, PieceColor.White) => "♗",
            (PieceType.Knight, PieceColor.White) => "♘",
            (PieceType.Pawn, PieceColor.White) => "♙",
            (PieceType.King, PieceColor.Black) => "♚",
            (PieceType.Queen, PieceColor.Black) => "♛",
            (PieceType.Rook, PieceColor.Black) => "♜",
            (PieceType.Bishop, PieceColor.Black) => "♝",
            (PieceType.Knight, PieceColor.Black) => "♞",
            (PieceType.Pawn, PieceColor.Black) => "♟",
            _ => ""
        };
    }

    private string GetNodeClass(MiniMaxNode node, bool isCurrent) {
        var classes = new List<string>();
        if (isCurrent) classes.Add("current");
        if (node.IsPruned) classes.Add("pruned");
        else if (node.IsBestMove) classes.Add("best-move");
        else if (node.IsMaximizing) classes.Add("maximizing");
        else classes.Add("minimizing");
        return string.Join(" ", classes);
    }
}

<style>
    .minimax-fullscreen {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: #fafafa;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 16px 24px;
        background: white;
        border-bottom: 1px solid #e5e5e5;
    }

    .header-left h1 {
        margin: 0 0 8px 0;
        font-size: 20px;
        font-weight: 600;
        color: #1d1d1f;
    }

    .stats-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }

    .stat-chip {
        display: flex;
        flex-direction: column;
        padding: 4px 10px;
        background: #f5f5f7;
        border-radius: 8px;
    }

    .stat-chip.stat-active { background: #007aff; }
    .stat-chip.stat-active .stat-label,
    .stat-chip.stat-active .stat-value { color: white; }
    .stat-label { font-size: 9px; color: #86868b; text-transform: uppercase; }
    .stat-value { font-size: 14px; font-weight: 600; color: #1d1d1f; }

    .close-btn {
        background: none;
        border: none;
        padding: 8px;
        cursor: pointer;
        color: #86868b;
        border-radius: 8px;
    }
    .close-btn:hover { background: #f5f5f7; color: #1d1d1f; }

    .empty-state {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #86868b;
    }

    .controls-bar {
        display: flex;
        align-items: center;
        padding: 10px 24px;
        background: white;
        border-bottom: 1px solid #e5e5e5;
        gap: 16px;
        flex-wrap: wrap;
    }

    .playback-controls {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .control-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px; height: 32px;
        border: none;
        background: #f5f5f7;
        border-radius: 6px;
        cursor: pointer;
        color: #1d1d1f;
    }
    .control-btn:hover:not(:disabled) { background: #e5e5e5; }
    .control-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .control-btn-primary {
        width: 40px; height: 40px;
        background: #007aff;
        color: white;
        border-radius: 50%;
    }
    .control-btn-primary:hover:not(:disabled) { background: #0056b3; }

    .view-modes {
        display: flex;
        background: #f5f5f7;
        border-radius: 6px;
        padding: 3px;
    }

    .mode-btn {
        padding: 5px 12px;
        border: none;
        background: transparent;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        color: #86868b;
        cursor: pointer;
    }
    .mode-btn:hover { color: #1d1d1f; }
    .mode-btn.active {
        background: white;
        color: #007aff;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .depth-control, .limit-control, .speed-slider {
        display: flex;
        align-items: center;
        gap: 6px;
    }
    .depth-label, .speed-label, .speed-value {
        font-size: 12px;
        color: #86868b;
    }
    .depth-select {
        padding: 4px 8px;
        border: 1px solid #e5e5e5;
        border-radius: 4px;
        font-size: 12px;
    }
    .speed-slider input[type="range"] {
        width: 80px;
        accent-color: #007aff;
    }
    .progress-display { margin-left: auto; }
    .progress-text { font-size: 12px; color: #86868b; }

    .legend-bar {
        display: flex;
        justify-content: center;
        gap: 20px;
        padding: 8px 24px;
        background: #f5f5f7;
        font-size: 11px;
    }
    .legend-item { display: flex; align-items: center; gap: 4px; color: #86868b; }
    .legend-dot { width: 8px; height: 8px; border-radius: 2px; }
    .legend-max { background: #34c759; }
    .legend-min { background: #ff9500; }
    .legend-pruned { background: #8e8e93; }
    .legend-best { background: #007aff; }
    .legend-current { background: #af52de; }

    .detail-panel {
        display: flex;
        gap: 20px;
        padding: 16px 24px;
        background: white;
        border-bottom: 1px solid #e5e5e5;
        align-items: center;
        justify-content: center;
    }

    .detail-board {
        display: flex;
        flex-direction: column;
        border: 2px solid #1d1d1f;
        border-radius: 4px;
        overflow: hidden;
    }
    .detail-row { display: flex; }
    .detail-cell {
        width: 28px; height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
    }
    .detail-cell.light { background: #f0d9b5; }
    .detail-cell.dark { background: #b58863; }
    .detail-cell.from { background: #ff9500 !important; }
    .detail-cell.to { background: #007aff !important; }
    .white-piece { color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    .black-piece { color: #000; }

    .detail-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    .detail-move { font-size: 24px; font-weight: 700; color: #1d1d1f; }
    .detail-type {
        font-size: 11px; font-weight: 600;
        padding: 3px 8px; border-radius: 4px;
        width: fit-content;
    }
    .detail-type.type-max { background: #d4edda; color: #155724; }
    .detail-type.type-min { background: #fff3cd; color: #856404; }
    .detail-score { font-size: 18px; font-weight: 600; color: #007aff; }
    .detail-ab { font-size: 12px; color: #86868b; font-family: monospace; }
    .detail-pruned {
        font-size: 11px; font-weight: 600;
        color: white; background: #8e8e93;
        padding: 2px 8px; border-radius: 4px;
        width: fit-content;
    }

    .tree-list-container {
        flex: 1;
        overflow: auto;
        padding: 8px 0;
        background: white;
    }

    .tree-node-row {
        display: flex;
        align-items: center;
        padding: 6px 12px;
        cursor: pointer;
        border-left: 3px solid transparent;
        transition: background 0.15s;
    }
    .tree-node-row:hover { background: #f5f5f7; }
    .tree-node-row.current {
        background: #f0f0ff;
        border-left-color: #af52de;
    }
    .tree-node-row.best-move { border-left-color: #007aff; }
    .tree-node-row.pruned { opacity: 0.5; }

    .node-indent {
        display: flex;
        align-items: center;
        color: #c7c7cc;
        font-family: monospace;
        font-size: 12px;
        margin-right: 8px;
    }
    .expand-toggle {
        width: 18px; height: 18px;
        border: 1px solid #d1d1d6;
        background: white;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
        color: #007aff;
        margin-right: 4px;
    }
    .expand-toggle:hover { background: #f5f5f7; }
    .expand-spacer { width: 22px; }
    .tree-line { color: #d1d1d6; }

    .node-content {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
    }
    .node-type-badge {
        font-size: 9px;
        font-weight: 600;
        padding: 2px 6px;
        border-radius: 3px;
    }
    .node-type-badge.max { background: #d4edda; color: #155724; }
    .node-type-badge.min { background: #fff3cd; color: #856404; }
    .node-move-name { font-weight: 600; color: #1d1d1f; }
    .node-score-value { color: #007aff; font-weight: 600; }
    .node-pruned-tag {
        font-size: 9px; font-weight: 600;
        color: white; background: #8e8e93;
        padding: 1px 5px; border-radius: 3px;
    }
    .node-best-tag {
        font-size: 9px; font-weight: 600;
        color: white; background: #007aff;
        padding: 1px 5px; border-radius: 3px;
    }
    .node-ab-values {
        font-size: 11px;
        color: #86868b;
        font-family: monospace;
    }
    .node-children-count {
        font-size: 11px;
        color: #86868b;
    }

    .truncation-notice {
        padding: 12px 24px;
        text-align: center;
        color: #86868b;
        font-size: 12px;
        background: #f5f5f7;
        border-top: 1px solid #e5e5e5;
    }
</style>
